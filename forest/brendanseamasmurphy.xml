<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>235</anchor>  <taxon>Person</taxon> <addr>brendanseamasmurphy</addr>  <route>brendanseamasmurphy.xml</route>   <title>Brendan Seamas Murphy</title> <meta name="external">https://www.brendan.phd/</meta><meta name="institution">University of Utah</meta><meta name="orcid">0009-0005-9870-5221</meta><meta name="position">PhD Student</meta></frontmatter> <mainmatter><p>I am a PhD student at the University of Utah working with Professor Srikanth Iyengar. I graduated from the University of Washington in Spring 2022 with a BS in Computer Science &amp; Mathematics. I'm broadly interested in commutative algebra, homotopy theory, logic, and formal verification.</p></mainmatter> <backmatter><contributions><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>236</anchor>  <taxon>Proposition</taxon> <addr>bnc-000C</addr>  <route>bnc-000C.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Orbits of the symmetric group action on functions</title> </frontmatter> <mainmatter><p>Let <tex>n, m  \in   \mathbb {N}</tex>. Since <tex>S_n =  \operatorname {Aut}_{ \mathsf { Fin } }( \mathbf {n} )</tex> there is a canonical right action of <tex>S_n</tex> on <tex>\operatorname {Hom}_{ \mathsf { Fin } }( \mathbf {n} ,  \mathbf {m} )</tex>, via precomposition. Each orbit of this action contains exactly one element of <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex>.</p>
  <block open="open"><headline><strong>Proof</strong>.</headline> <p>Define the weight of an <tex>m</tex>-tuple <tex>\alpha</tex> of natural numbers by <tex>| \alpha | =  \sum _{j  \in   \mathbf {m}}  \alpha _j</tex>. For any function <tex>f  \in   \operatorname {Hom}_{ \mathsf { Fin } }( \mathbf {n} ,  \mathbf {m} )</tex> define an <tex>m</tex>-tuple <tex>\alpha ^f :  \mathbf {m}  \to   \mathbb {N}</tex> by <tex>\alpha ^f_j = |f^{-1}(j)|</tex>. Since the fibers of <tex>f</tex> are disjoint we have <tex display="block">| \alpha ^f| =  \sum _{j  \in   \mathbf {m}} |f^{-1}(j)| =  \left | \bigcup _{j  \in   \mathbf {m}} f^{-1}(j)  \right | =  \left |f^{-1} \left ( \bigcup _{j  \in   \mathbf {m}}  \{ j \} \right )  \right | = |f^{-1}( \mathbf {m})| = | \mathbf {n}| = n.</tex></p>

<p>We argue that <tex>f, g</tex> lie in the same orbit if and only if <tex>\alpha ^f =  \alpha ^g</tex>. For &quot;only if&quot; direction we just observe that <tex>f =  g   \mathbin { \circ }  \sigma</tex> implies <tex>\sigma (f^{-1}(j)) = g^{-1}(j)</tex> for any <tex>j  \in   \mathbf {m}</tex>, hence <tex>\sigma</tex> restricts to a bijection between <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> and so <tex>\alpha ^f_j = |f^{-1}(j)| = |g^{-1}(j)| =  \alpha ^g_j</tex>, as desired. Suppose <tex>\alpha ^f =  \alpha ^g</tex>, so that we may prove the other implication. Then for any <tex>j \in   \mathbf {m}</tex> we have <tex>|f^{-1}(j)| = |g^{-1}(j)|</tex>, i.e. the sets <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> are in bijection. We may then fix arbitrary bijections <tex>\sigma _j : f^{-1}(j)  \to  g^{-1}(j)</tex>. By construction we have <tex>g( \sigma _{f(i)}(i)) = f(i)</tex>. Define a function <tex>\sigma  :  \mathbf {n}  \to   \mathbf {n}</tex> by <tex>\sigma (i) =  \sigma _{f(i)}(i)</tex>; this is well defined because (trivially) <tex>i  \in  f^{-1}(f(i))</tex>. For any <tex>j  \in   \mathbf {m}</tex> and <tex>i'  \in  g^{-1}(j)</tex> the element <tex>i =  \sigma _j^{-1}(j)</tex> satisfies <tex>i  \in  f^{-1}(j)</tex> and thus <tex display="block">\sigma (i) =  \sigma _{j}(i) =  \sigma _{j}( \sigma _j^{-1}(j)) = i.</tex>
This proves that <tex>\operatorname {im}( \sigma )   \supseteq  g^{-1}(j)</tex> for any <tex>j  \in   \mathbf {m}</tex>. And it's immediate from this that <tex>\sigma</tex> is surjective, since the union of the fibers <tex>g^{-1}(j)</tex> over all <tex>j  \in   \mathbf {m}</tex> is <tex>\mathbf {n}</tex>. Since <tex>\sigma</tex> has domain and codomain finite sets of the same cardinality, surjectivity in fact implies <tex>\sigma   \in  S_n</tex>. Finally observe that <tex>f = g  \circ   \sigma</tex>, as we have defined <tex>\sigma</tex> such that this equation holds on each fiber <tex>f^{-1}(j)</tex>.</p>
 
<p>To complete our proof we need to show that the association <tex>f  \mapsto   \alpha ^f</tex> defines a bijection between <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> and the set <tex>X</tex> of <tex>m</tex>-tuples with weight <tex>n</tex>. Let <tex>\Phi  :  \operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )   \to  X</tex> be this function. Awkwardly we need to treat the case <tex>m = 0</tex> separately. Here we further case split on whether <tex>n = 0</tex>, in which case <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> and <tex>X</tex> both have a unique element, or <tex>n  \neq  0</tex>, in which case both sets are empty. Either way, <tex>\Phi</tex> is automatically a bijection. So now assume <tex>m &gt; 0</tex>. We define an inverse <tex>\Psi  : X  \to   \operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> by <tex display="block">\Psi ( \alpha )(i) =  \max   \left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \right \} .</tex> Before we can check that <tex>\Psi</tex> is an inverse to <tex>\Phi</tex> we must show that <tex>\Psi ( \alpha )</tex> is a well-defined function <tex>\mathbf {n}  \to   \mathbf {m}</tex> for any <tex>\alpha   \in  X</tex>, and that this function is monotone. The function is well-defined because any nonempty totally ordered set has a maximum and the set in the definition of <tex>\Psi ( \alpha )</tex> always contains <tex>0</tex>. And <tex>\Psi ( \alpha )</tex> is monotone because if <tex>i_1  \leq  i_2</tex> then <tex>i_0  \leq  i_1</tex> only if <tex>i_0  \leq  i_2</tex> and thus <tex display="block">\left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_1  \right \}   \subseteq   \left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_2  \right \} .</tex> Clearly taking the maximum of a larger sets gives a larger result, so this inclusion proves <tex>\Psi ( \alpha )(i_1)  \leq   \Psi ( \alpha )(i_2)</tex>. We may now check that <tex>\Phi</tex> and <tex>\Psi</tex> are inverses. Given <tex>\alpha   \in  X</tex> we have <tex display="block">\Phi ( \Psi ( \alpha ))_k = | \Psi ( \alpha )^{-1}(k)| =  \left | \left \{  i  \in   \mathbf {n}  \; \middle | \;     \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \text { and } i &lt;  \sum _{0  \leq  j  \leq  k}  \alpha _j  \right \} \right | =  \alpha _k</tex> for any <tex>k  \in   \mathbf {m}</tex>. We establish the identity <tex>\Psi ( \Phi (f)) = f</tex> by showing that <tex>\sum _{0  \leq  j &lt; k} |f^{-1}(j)|  \leq  i</tex> if and only if <tex>k  \leq  f(i)</tex>, for any monotone function <tex>f :  \mathbf {n}  \to   \mathbf {m}</tex>, <tex>i  \in   \mathbf {n}</tex>, and <tex>k  \in   \mathbf {m}</tex> (from which it is obvious that <tex>\Psi ( \Phi (f))(i) = f(i)</tex>). Let <tex>\ell  =  \sum _{0  \leq  j &lt; k} |f^{-1}(j)|</tex>; we show <tex>\ell  &gt; i</tex> iff <tex>k &gt; f(i)</tex>. By monotonicity of <tex>f</tex> the set <tex>f^{-1}( \mathbf {k})  \subseteq   \mathbf {n}</tex> is downwards-closed, hence it is itself an ordinal and more specifically <tex>f^{-1}( \mathbf {k}) =  \mathbf { \ell }</tex>. Thus <tex>\ell  &gt; i</tex> iff <tex>i  \in  f^{-1}( \mathbf {k})</tex> iff <tex>f(i)  \in   \mathbf {k}</tex> iff <tex>f(i) &lt; k</tex>.
</p></block>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>237</anchor>  <taxon>Definition</taxon> <addr>bnc-000B</addr>  <route>bnc-000B.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>The symmetric groups</title> </frontmatter> <mainmatter><p>The symmetric group <tex>S_n</tex>, defined with respect to a parameter <tex>n  \in   \mathbb {N}</tex>, is the set of permutations of the <tex>n</tex>-element set. Of course there is a proper class of <tex>n</tex>-element sets and so for concreteness we define <tex>S_n</tex> to be the group of self-bijections of the <tex>n</tex>th ordinal <tex>\mathbf {n} =  \{ i  \in   \mathbb {N}   \mid  i &lt; n \}</tex>.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>238</anchor>   <addr>bnc-0006</addr>  <route>bnc-0006.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Combinatorics and categories</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>239</anchor>  <taxon>Definition</taxon> <addr>bnc-0007</addr>  <route>bnc-0007.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Simplex Category</title> </frontmatter> <mainmatter><p>The simplex category is the category <tex>\Delta</tex> whose objects are the finite ordinals <tex>\mathbf {n} =  \{  i  \in   \mathbb {N}   \mid  i &lt; n  \}  =  \{ 0, \ldots ,n-1 \}</tex> and whose morphisms are the order preserving maps; note <tex>\Delta</tex> is a full subcategory of the category <tex>\mathsf { Pos }</tex> of posets. We include the empty set <tex>\mathbf {0}</tex>, so in other conventions this would be called the &quot;augmented simplex category&quot; or the &quot;algebraists' simplex category&quot;.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>240</anchor>  <taxon>Definition</taxon> <addr>bnc-0008</addr>  <route>bnc-0008.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Variants of the category of finite sets</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { FinSet }</tex> be the category of finite sets. This is a large, locally small category but it has only countably many isomorphism classes. The set <tex>\omega</tex> of finite ordinals (equivalently finite cardinals) contains exactly one object in each isomorphism class of <tex>\mathsf { FinSet }</tex>, hence if <tex>\mathsf { Fin }</tex> is the full subcategory of <tex>\mathsf { FinSet }</tex> on objects <tex>\omega</tex> then the inclusion <tex>\mathsf { Fin }   \hookrightarrow   \mathsf { FinSet }</tex> is essentially surjective. It is also manifestly fully faithful, i.e. an equivalence of categories (although it's consistent that there is no quasi-inverse, in the absence of global choice!). The fact that there is <em>exactly</em> one. Another small model for <tex>\mathsf { Fin }</tex> is the full subcategory <tex>\mathsf { HFinSet }</tex> of <tex>\mathsf { FinSet }</tex> on <tex>V_{ \omega }</tex>, the hereditarily finite sets. This latter model is nice in that it is closed under finite limits and colimits in a very strong sense: the <em>standard constructions</em> of (co)limits in <tex>\mathsf { Set }</tex> will produce hereditarily finite sets when applied to hereditarily finite diagrams of hereditarily finite sets. In summary we have full subcategory inclusions <tex>\mathsf { Fin }   \subseteq   \mathsf { HFinSet }   \subseteq   \mathsf { Set }</tex>, each being an equivalence, and each of these categories is an elementary topos and the inclusion <tex>\mathsf { HFinSet }   \subseteq   \mathsf { Set }</tex> preserves &quot;explicit choices of (co)limits&quot; when that makes sense.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>241</anchor>  <taxon>Definition</taxon> <addr>bnc-000B</addr>  <route>bnc-000B.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>The symmetric groups</title> </frontmatter> <mainmatter><p>The symmetric group <tex>S_n</tex>, defined with respect to a parameter <tex>n  \in   \mathbb {N}</tex>, is the set of permutations of the <tex>n</tex>-element set. Of course there is a proper class of <tex>n</tex>-element sets and so for concreteness we define <tex>S_n</tex> to be the group of self-bijections of the <tex>n</tex>th ordinal <tex>\mathbf {n} =  \{ i  \in   \mathbb {N}   \mid  i &lt; n \}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>242</anchor>  <taxon>Proposition</taxon> <addr>bnc-000C</addr>  <route>bnc-000C.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Orbits of the symmetric group action on functions</title> </frontmatter> <mainmatter><p>Let <tex>n, m  \in   \mathbb {N}</tex>. Since <tex>S_n =  \operatorname {Aut}_{ \mathsf { Fin } }( \mathbf {n} )</tex> there is a canonical right action of <tex>S_n</tex> on <tex>\operatorname {Hom}_{ \mathsf { Fin } }( \mathbf {n} ,  \mathbf {m} )</tex>, via precomposition. Each orbit of this action contains exactly one element of <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex>.</p>
  <block open="open"><headline><strong>Proof</strong>.</headline> <p>Define the weight of an <tex>m</tex>-tuple <tex>\alpha</tex> of natural numbers by <tex>| \alpha | =  \sum _{j  \in   \mathbf {m}}  \alpha _j</tex>. For any function <tex>f  \in   \operatorname {Hom}_{ \mathsf { Fin } }( \mathbf {n} ,  \mathbf {m} )</tex> define an <tex>m</tex>-tuple <tex>\alpha ^f :  \mathbf {m}  \to   \mathbb {N}</tex> by <tex>\alpha ^f_j = |f^{-1}(j)|</tex>. Since the fibers of <tex>f</tex> are disjoint we have <tex display="block">| \alpha ^f| =  \sum _{j  \in   \mathbf {m}} |f^{-1}(j)| =  \left | \bigcup _{j  \in   \mathbf {m}} f^{-1}(j)  \right | =  \left |f^{-1} \left ( \bigcup _{j  \in   \mathbf {m}}  \{ j \} \right )  \right | = |f^{-1}( \mathbf {m})| = | \mathbf {n}| = n.</tex></p>

<p>We argue that <tex>f, g</tex> lie in the same orbit if and only if <tex>\alpha ^f =  \alpha ^g</tex>. For &quot;only if&quot; direction we just observe that <tex>f =  g   \mathbin { \circ }  \sigma</tex> implies <tex>\sigma (f^{-1}(j)) = g^{-1}(j)</tex> for any <tex>j  \in   \mathbf {m}</tex>, hence <tex>\sigma</tex> restricts to a bijection between <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> and so <tex>\alpha ^f_j = |f^{-1}(j)| = |g^{-1}(j)| =  \alpha ^g_j</tex>, as desired. Suppose <tex>\alpha ^f =  \alpha ^g</tex>, so that we may prove the other implication. Then for any <tex>j \in   \mathbf {m}</tex> we have <tex>|f^{-1}(j)| = |g^{-1}(j)|</tex>, i.e. the sets <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> are in bijection. We may then fix arbitrary bijections <tex>\sigma _j : f^{-1}(j)  \to  g^{-1}(j)</tex>. By construction we have <tex>g( \sigma _{f(i)}(i)) = f(i)</tex>. Define a function <tex>\sigma  :  \mathbf {n}  \to   \mathbf {n}</tex> by <tex>\sigma (i) =  \sigma _{f(i)}(i)</tex>; this is well defined because (trivially) <tex>i  \in  f^{-1}(f(i))</tex>. For any <tex>j  \in   \mathbf {m}</tex> and <tex>i'  \in  g^{-1}(j)</tex> the element <tex>i =  \sigma _j^{-1}(j)</tex> satisfies <tex>i  \in  f^{-1}(j)</tex> and thus <tex display="block">\sigma (i) =  \sigma _{j}(i) =  \sigma _{j}( \sigma _j^{-1}(j)) = i.</tex>
This proves that <tex>\operatorname {im}( \sigma )   \supseteq  g^{-1}(j)</tex> for any <tex>j  \in   \mathbf {m}</tex>. And it's immediate from this that <tex>\sigma</tex> is surjective, since the union of the fibers <tex>g^{-1}(j)</tex> over all <tex>j  \in   \mathbf {m}</tex> is <tex>\mathbf {n}</tex>. Since <tex>\sigma</tex> has domain and codomain finite sets of the same cardinality, surjectivity in fact implies <tex>\sigma   \in  S_n</tex>. Finally observe that <tex>f = g  \circ   \sigma</tex>, as we have defined <tex>\sigma</tex> such that this equation holds on each fiber <tex>f^{-1}(j)</tex>.</p>
 
<p>To complete our proof we need to show that the association <tex>f  \mapsto   \alpha ^f</tex> defines a bijection between <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> and the set <tex>X</tex> of <tex>m</tex>-tuples with weight <tex>n</tex>. Let <tex>\Phi  :  \operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )   \to  X</tex> be this function. Awkwardly we need to treat the case <tex>m = 0</tex> separately. Here we further case split on whether <tex>n = 0</tex>, in which case <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> and <tex>X</tex> both have a unique element, or <tex>n  \neq  0</tex>, in which case both sets are empty. Either way, <tex>\Phi</tex> is automatically a bijection. So now assume <tex>m &gt; 0</tex>. We define an inverse <tex>\Psi  : X  \to   \operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> by <tex display="block">\Psi ( \alpha )(i) =  \max   \left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \right \} .</tex> Before we can check that <tex>\Psi</tex> is an inverse to <tex>\Phi</tex> we must show that <tex>\Psi ( \alpha )</tex> is a well-defined function <tex>\mathbf {n}  \to   \mathbf {m}</tex> for any <tex>\alpha   \in  X</tex>, and that this function is monotone. The function is well-defined because any nonempty totally ordered set has a maximum and the set in the definition of <tex>\Psi ( \alpha )</tex> always contains <tex>0</tex>. And <tex>\Psi ( \alpha )</tex> is monotone because if <tex>i_1  \leq  i_2</tex> then <tex>i_0  \leq  i_1</tex> only if <tex>i_0  \leq  i_2</tex> and thus <tex display="block">\left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_1  \right \}   \subseteq   \left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_2  \right \} .</tex> Clearly taking the maximum of a larger sets gives a larger result, so this inclusion proves <tex>\Psi ( \alpha )(i_1)  \leq   \Psi ( \alpha )(i_2)</tex>. We may now check that <tex>\Phi</tex> and <tex>\Psi</tex> are inverses. Given <tex>\alpha   \in  X</tex> we have <tex display="block">\Phi ( \Psi ( \alpha ))_k = | \Psi ( \alpha )^{-1}(k)| =  \left | \left \{  i  \in   \mathbf {n}  \; \middle | \;     \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \text { and } i &lt;  \sum _{0  \leq  j  \leq  k}  \alpha _j  \right \} \right | =  \alpha _k</tex> for any <tex>k  \in   \mathbf {m}</tex>. We establish the identity <tex>\Psi ( \Phi (f)) = f</tex> by showing that <tex>\sum _{0  \leq  j &lt; k} |f^{-1}(j)|  \leq  i</tex> if and only if <tex>k  \leq  f(i)</tex>, for any monotone function <tex>f :  \mathbf {n}  \to   \mathbf {m}</tex>, <tex>i  \in   \mathbf {n}</tex>, and <tex>k  \in   \mathbf {m}</tex> (from which it is obvious that <tex>\Psi ( \Phi (f))(i) = f(i)</tex>). Let <tex>\ell  =  \sum _{0  \leq  j &lt; k} |f^{-1}(j)|</tex>; we show <tex>\ell  &gt; i</tex> iff <tex>k &gt; f(i)</tex>. By monotonicity of <tex>f</tex> the set <tex>f^{-1}( \mathbf {k})  \subseteq   \mathbf {n}</tex> is downwards-closed, hence it is itself an ordinal and more specifically <tex>f^{-1}( \mathbf {k}) =  \mathbf { \ell }</tex>. Thus <tex>\ell  &gt; i</tex> iff <tex>i  \in  f^{-1}( \mathbf {k})</tex> iff <tex>f(i)  \in   \mathbf {k}</tex> iff <tex>f(i) &lt; k</tex>.
</p></block>
</mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>243</anchor>  <taxon>Definition</taxon> <addr>bnc-0007</addr>  <route>bnc-0007.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Simplex Category</title> </frontmatter> <mainmatter><p>The simplex category is the category <tex>\Delta</tex> whose objects are the finite ordinals <tex>\mathbf {n} =  \{  i  \in   \mathbb {N}   \mid  i &lt; n  \}  =  \{ 0, \ldots ,n-1 \}</tex> and whose morphisms are the order preserving maps; note <tex>\Delta</tex> is a full subcategory of the category <tex>\mathsf { Pos }</tex> of posets. We include the empty set <tex>\mathbf {0}</tex>, so in other conventions this would be called the &quot;augmented simplex category&quot; or the &quot;algebraists' simplex category&quot;.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>244</anchor>  <taxon>Definition</taxon> <addr>bnc-0008</addr>  <route>bnc-0008.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Variants of the category of finite sets</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { FinSet }</tex> be the category of finite sets. This is a large, locally small category but it has only countably many isomorphism classes. The set <tex>\omega</tex> of finite ordinals (equivalently finite cardinals) contains exactly one object in each isomorphism class of <tex>\mathsf { FinSet }</tex>, hence if <tex>\mathsf { Fin }</tex> is the full subcategory of <tex>\mathsf { FinSet }</tex> on objects <tex>\omega</tex> then the inclusion <tex>\mathsf { Fin }   \hookrightarrow   \mathsf { FinSet }</tex> is essentially surjective. It is also manifestly fully faithful, i.e. an equivalence of categories (although it's consistent that there is no quasi-inverse, in the absence of global choice!). The fact that there is <em>exactly</em> one. Another small model for <tex>\mathsf { Fin }</tex> is the full subcategory <tex>\mathsf { HFinSet }</tex> of <tex>\mathsf { FinSet }</tex> on <tex>V_{ \omega }</tex>, the hereditarily finite sets. This latter model is nice in that it is closed under finite limits and colimits in a very strong sense: the <em>standard constructions</em> of (co)limits in <tex>\mathsf { Set }</tex> will produce hereditarily finite sets when applied to hereditarily finite diagrams of hereditarily finite sets. In summary we have full subcategory inclusions <tex>\mathsf { Fin }   \subseteq   \mathsf { HFinSet }   \subseteq   \mathsf { Set }</tex>, each being an equivalence, and each of these categories is an elementary topos and the inclusion <tex>\mathsf { HFinSet }   \subseteq   \mathsf { Set }</tex> preserves &quot;explicit choices of (co)limits&quot; when that makes sense.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>245</anchor>  <taxon>Definition</taxon> <addr>bnc-0005</addr>  <route>bnc-0005.xml</route> <date><year>2023</year> <month>9</month> <day>28</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Monoidal Category</title> </frontmatter> <mainmatter><p>A monoidal category consists of a <link href="bnc-0002.xml" type="local" title="Category">category</link> <tex>\mathsf { M }</tex>, a <link href="bnc-0003.xml" type="local" title="Functor">functor</link> <tex>\otimes  :  \mathsf { C }   \times   \mathsf { C }   \to   \mathsf { C }</tex>, an object <tex>\mathbb {k}</tex> of <tex>\mathsf { M }</tex>, and <link href="bnc-0004.xml" type="local" title="Natural Transformation">natural isomorphisms</link> <tex>\alpha _{x,y,z} : (x  \otimes  y)  \otimes  z  \to   x  \otimes  (y  \otimes  z)</tex>, <tex>\lambda _x :  \mathbb {k}  \otimes  x  \to  x</tex>, and <tex>\rho _x : x  \otimes   \mathbb {k}  \to  x</tex>.</p><img src="resources/aedd76b89a71ad19918e42536abd8f51-web.svg"/></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>246</anchor>  <taxon>Definition</taxon> <addr>bnc-0002</addr>  <route>bnc-0002.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Category</title> </frontmatter> <mainmatter><p>A category <tex>\mathsf { C }</tex> consists of classes <tex>C_0</tex>, <tex>C_1</tex>, class functions <tex>s,t : C_1  \to  C_0</tex>, a common section <tex>\operatorname {id} : C_0  \to  C_1</tex> of <tex>s, t</tex>, and a partial operator <tex>\circ  : C_1  \times  C_1  \rightharpoonup  C_1</tex> where <tex>f   \mathbin { \circ }  g</tex> is defined iff <tex>s(f) = t(g)</tex>. The axioms of a category are:</p><ol><li><tex>s( f   \mathbin { \circ }  g ) = s(g)</tex> and <tex>t( f   \mathbin { \circ }  g ) = t(f)</tex> for any <tex>f, g \in  C_1</tex> such that <tex>s(f) = t(g)</tex>,</li>
  <li><tex>\operatorname {id} _{ t(f) }   \mathbin { \circ }  f  = f =  f   \mathbin { \circ }  \operatorname {id} _{ s(f) }</tex> for any <tex>f \in  C_1</tex>,</li>
  <li>for any <tex>f, g, h  \in  C_1</tex> such that <tex>s(f) = t(g)</tex> and <tex>s(g) = t(h)</tex>, <tex display="block">f   \mathbin { \circ }  ( g   \mathbin { \circ }  h )  =  ( f   \mathbin { \circ }  g )   \mathbin { \circ }  h .</tex></li></ol><p>As above, we usually write <tex>\circ</tex> as an infix operator and write application of <tex>\operatorname {id}</tex> with a subscript.</p><p>If <tex>x,y  \in  C_0</tex> we define <tex>\operatorname {Hom}_{ \mathsf { C } }( x ,  y )  = s ^{ -1 } (x)  \cap  t ^{ -1 } (y)</tex>, so <tex>\operatorname {id} _{ x }   \in   \operatorname {Hom}_{ \mathsf { C } }( x ,  x )</tex>. For <tex>f  \in  C_1</tex> we refer to <tex>s(f)</tex> as the &quot;source&quot; of <tex>f</tex> and <tex>t(f)</tex> as the &quot;target&quot; of <tex>f</tex>. A category <tex>\mathsf { C }</tex> is said to be small if <tex>C_1</tex> is a set (which implies <tex>C_0</tex> is a set) and to be locally small if <tex>\operatorname {Hom}_{ \mathsf { C } }( x ,  y )</tex> is a set for all <tex>x, y  \in  C_0</tex>. For a general category <tex>\mathsf { C }</tex> we refer to <tex>\operatorname {Hom}_{ \mathsf { C } }( x ,  y )</tex> as a <tex>\operatorname {Hom}</tex>-class of <tex>\mathsf { C }</tex>, and if <tex>\mathsf { C }</tex> is locally small we call it a <tex>\operatorname {Hom}</tex>-<em>set</em>. We write <tex>\operatorname {Obj}( \mathsf { C } )</tex> for the class <tex>C_0</tex> and <tex>\operatorname {Mor}( \mathsf { C } )</tex> for <tex>C_1</tex>.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>247</anchor>   <addr>bnc-0001</addr>  <route>bnc-0001.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Foundations of category theory</title> </frontmatter> <mainmatter><p>In the following we work in NBG set theory with the axiom of choice but not of global choice. I will probably crack at some point and bring in universes. I intend for these notes to be as self contained as possible, but that goal may change.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>248</anchor>  <taxon>Definition</taxon> <addr>bnc-0002</addr>  <route>bnc-0002.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Category</title> </frontmatter> <mainmatter><p>A category <tex>\mathsf { C }</tex> consists of classes <tex>C_0</tex>, <tex>C_1</tex>, class functions <tex>s,t : C_1  \to  C_0</tex>, a common section <tex>\operatorname {id} : C_0  \to  C_1</tex> of <tex>s, t</tex>, and a partial operator <tex>\circ  : C_1  \times  C_1  \rightharpoonup  C_1</tex> where <tex>f   \mathbin { \circ }  g</tex> is defined iff <tex>s(f) = t(g)</tex>. The axioms of a category are:</p><ol><li><tex>s( f   \mathbin { \circ }  g ) = s(g)</tex> and <tex>t( f   \mathbin { \circ }  g ) = t(f)</tex> for any <tex>f, g \in  C_1</tex> such that <tex>s(f) = t(g)</tex>,</li>
  <li><tex>\operatorname {id} _{ t(f) }   \mathbin { \circ }  f  = f =  f   \mathbin { \circ }  \operatorname {id} _{ s(f) }</tex> for any <tex>f \in  C_1</tex>,</li>
  <li>for any <tex>f, g, h  \in  C_1</tex> such that <tex>s(f) = t(g)</tex> and <tex>s(g) = t(h)</tex>, <tex display="block">f   \mathbin { \circ }  ( g   \mathbin { \circ }  h )  =  ( f   \mathbin { \circ }  g )   \mathbin { \circ }  h .</tex></li></ol><p>As above, we usually write <tex>\circ</tex> as an infix operator and write application of <tex>\operatorname {id}</tex> with a subscript.</p><p>If <tex>x,y  \in  C_0</tex> we define <tex>\operatorname {Hom}_{ \mathsf { C } }( x ,  y )  = s ^{ -1 } (x)  \cap  t ^{ -1 } (y)</tex>, so <tex>\operatorname {id} _{ x }   \in   \operatorname {Hom}_{ \mathsf { C } }( x ,  x )</tex>. For <tex>f  \in  C_1</tex> we refer to <tex>s(f)</tex> as the &quot;source&quot; of <tex>f</tex> and <tex>t(f)</tex> as the &quot;target&quot; of <tex>f</tex>. A category <tex>\mathsf { C }</tex> is said to be small if <tex>C_1</tex> is a set (which implies <tex>C_0</tex> is a set) and to be locally small if <tex>\operatorname {Hom}_{ \mathsf { C } }( x ,  y )</tex> is a set for all <tex>x, y  \in  C_0</tex>. For a general category <tex>\mathsf { C }</tex> we refer to <tex>\operatorname {Hom}_{ \mathsf { C } }( x ,  y )</tex> as a <tex>\operatorname {Hom}</tex>-class of <tex>\mathsf { C }</tex>, and if <tex>\mathsf { C }</tex> is locally small we call it a <tex>\operatorname {Hom}</tex>-<em>set</em>. We write <tex>\operatorname {Obj}( \mathsf { C } )</tex> for the class <tex>C_0</tex> and <tex>\operatorname {Mor}( \mathsf { C } )</tex> for <tex>C_1</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb></trail> <anchor>249</anchor>  <taxon>Definition</taxon> <addr>bnc-0003</addr>  <route>bnc-0003.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { C }</tex> and <tex>\mathsf { D }</tex> be <link href="bnc-0002.xml" type="local" title="Category">categories</link>. A functor <tex>F :  \mathsf { C }   \to   \mathsf { D }</tex> consists of class functions <tex>F_0 :  \operatorname {Obj}( \mathsf { C } )   \to   \operatorname {Obj}( \mathsf { D } )</tex> and <tex>F_1 :  \operatorname {Mor}( \mathsf { C } )   \to   \operatorname {Mor}( \mathsf { D } )</tex>. The axioms of a functor are:</p><ol><li><tex>F_1( \operatorname {id} _{ x } ) =  \operatorname {id} _{ F_0(x) }</tex> for any <tex>x  \in   \operatorname {Obj}( \mathsf { C } )</tex>,</li>
  <li><tex>s(F_1(f)) = F_0(s(f))</tex> and <tex>t(F_1(f)) = F_0(t(f))</tex> for any <tex>f  \in   \operatorname {Mor}( \mathsf { C } )</tex>,</li>
  <li>for any <tex>f, g  \in   \operatorname {Mor}( \mathsf { C } )</tex> if <tex>s(f) = t(g)</tex> then <tex>F_1( f   \mathbin { \circ }  g ) =  F_1(f)   \mathbin { \circ }  F_1(g)</tex>.</li></ol><p>If <tex>\mathsf { C }</tex> is small then the functions <tex>F_0 :  \operatorname {Obj}( \mathsf { C } )   \to   \operatorname {Obj}( \mathsf { D } )</tex>, <tex>F_1 :  \operatorname {Mor}( \mathsf { C } )   \to   \operatorname {Mor}( \mathsf { D } )</tex> are actually sets (not proper classes), as their domains are sets. There is then a class of all functors <tex>\mathsf { C }   \to   \mathsf { D }</tex> (even if <tex>\mathsf { D }</tex> is large). For <tex>x  \in   \operatorname {Obj}( \mathsf { C } )</tex> and <tex>f  \in   \operatorname {Mor}( \mathsf { C } )</tex> we'll generally write <tex>F(x)</tex> to mean <tex>F_0(x)</tex> and <tex>F(f)</tex> to mean <tex>F_1(f)</tex>; this is undoubtedly ambiguous, but it's usually clear which is meant from context.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>7</crumb></trail> <anchor>250</anchor>  <taxon>Definition</taxon> <addr>bnc-0004</addr>  <route>bnc-0004.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Natural Transformation</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { C }</tex>, <tex>\mathsf { D }</tex> be <link href="bnc-0002.xml" type="local" title="Category">categories</link> and <tex>F, G :  \mathsf { C }   \to   \mathsf { D }</tex> <link href="bnc-0003.xml" type="local" title="Functor">functors</link> between them. The data of a natural transformation <tex>\alpha  : F  \to  G</tex> is a class function <tex>\operatorname {Obj}( \mathsf { C } )   \to   \operatorname {Mor}( \mathsf { D } )</tex> (also denoted <tex>\alpha</tex>). The axioms of a natural transformation are:</p><ol><li><tex>\alpha _x  \in   \operatorname {Hom}_{ \mathsf { D } }( F(x) ,  G(x) )</tex> for any <tex>x  \in   \operatorname {Obj}( \mathsf { C } )</tex>,</li>
  <li>For any <tex>f  \in   \operatorname {Mor}( \mathsf { C } )</tex>, if <tex>x = s(f)</tex> and <tex>y = t(f)</tex> then <tex>\alpha _y   \mathbin { \circ }  F(f)  =  G(f)   \mathbin { \circ }  \alpha _x</tex>.</li></ol><p>As above, we usually write application of natural transformations with a subscript. Also, if a natural transformation has an inverse natural transformation we refer to it as a natural isomorphism.</p><p>In analogy with representation theory we could think of <tex>\alpha</tex> as an &quot;intertwiner&quot; betwen <tex>F</tex> and <tex>G</tex>. As functors are morphisms between categories, natural transformations are morphisms between functors. Also, if <tex>\mathsf { C }</tex> is a small category and <tex>F, G</tex> are functors out of <tex>\mathsf { C }   \to   \mathsf { D }</tex> then individual natural transformations <tex>F  \to  G</tex> are sets, hence they can be collected into a class of all natural transformations <tex>F  \to  G</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb></trail> <anchor>251</anchor>   <addr>bnc-0006</addr>  <route>bnc-0006.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Combinatorics and categories</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>1</crumb></trail> <anchor>252</anchor>  <taxon>Definition</taxon> <addr>bnc-0007</addr>  <route>bnc-0007.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Simplex Category</title> </frontmatter> <mainmatter><p>The simplex category is the category <tex>\Delta</tex> whose objects are the finite ordinals <tex>\mathbf {n} =  \{  i  \in   \mathbb {N}   \mid  i &lt; n  \}  =  \{ 0, \ldots ,n-1 \}</tex> and whose morphisms are the order preserving maps; note <tex>\Delta</tex> is a full subcategory of the category <tex>\mathsf { Pos }</tex> of posets. We include the empty set <tex>\mathbf {0}</tex>, so in other conventions this would be called the &quot;augmented simplex category&quot; or the &quot;algebraists' simplex category&quot;.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>2</crumb></trail> <anchor>253</anchor>  <taxon>Definition</taxon> <addr>bnc-0008</addr>  <route>bnc-0008.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Variants of the category of finite sets</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { FinSet }</tex> be the category of finite sets. This is a large, locally small category but it has only countably many isomorphism classes. The set <tex>\omega</tex> of finite ordinals (equivalently finite cardinals) contains exactly one object in each isomorphism class of <tex>\mathsf { FinSet }</tex>, hence if <tex>\mathsf { Fin }</tex> is the full subcategory of <tex>\mathsf { FinSet }</tex> on objects <tex>\omega</tex> then the inclusion <tex>\mathsf { Fin }   \hookrightarrow   \mathsf { FinSet }</tex> is essentially surjective. It is also manifestly fully faithful, i.e. an equivalence of categories (although it's consistent that there is no quasi-inverse, in the absence of global choice!). The fact that there is <em>exactly</em> one. Another small model for <tex>\mathsf { Fin }</tex> is the full subcategory <tex>\mathsf { HFinSet }</tex> of <tex>\mathsf { FinSet }</tex> on <tex>V_{ \omega }</tex>, the hereditarily finite sets. This latter model is nice in that it is closed under finite limits and colimits in a very strong sense: the <em>standard constructions</em> of (co)limits in <tex>\mathsf { Set }</tex> will produce hereditarily finite sets when applied to hereditarily finite diagrams of hereditarily finite sets. In summary we have full subcategory inclusions <tex>\mathsf { Fin }   \subseteq   \mathsf { HFinSet }   \subseteq   \mathsf { Set }</tex>, each being an equivalence, and each of these categories is an elementary topos and the inclusion <tex>\mathsf { HFinSet }   \subseteq   \mathsf { Set }</tex> preserves &quot;explicit choices of (co)limits&quot; when that makes sense.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>3</crumb></trail> <anchor>254</anchor>  <taxon>Definition</taxon> <addr>bnc-000B</addr>  <route>bnc-000B.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>The symmetric groups</title> </frontmatter> <mainmatter><p>The symmetric group <tex>S_n</tex>, defined with respect to a parameter <tex>n  \in   \mathbb {N}</tex>, is the set of permutations of the <tex>n</tex>-element set. Of course there is a proper class of <tex>n</tex>-element sets and so for concreteness we define <tex>S_n</tex> to be the group of self-bijections of the <tex>n</tex>th ordinal <tex>\mathbf {n} =  \{ i  \in   \mathbb {N}   \mid  i &lt; n \}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb> <crumb>4</crumb></trail> <anchor>255</anchor>  <taxon>Proposition</taxon> <addr>bnc-000C</addr>  <route>bnc-000C.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Orbits of the symmetric group action on functions</title> </frontmatter> <mainmatter><p>Let <tex>n, m  \in   \mathbb {N}</tex>. Since <tex>S_n =  \operatorname {Aut}_{ \mathsf { Fin } }( \mathbf {n} )</tex> there is a canonical right action of <tex>S_n</tex> on <tex>\operatorname {Hom}_{ \mathsf { Fin } }( \mathbf {n} ,  \mathbf {m} )</tex>, via precomposition. Each orbit of this action contains exactly one element of <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex>.</p>
  <block open="open"><headline><strong>Proof</strong>.</headline> <p>Define the weight of an <tex>m</tex>-tuple <tex>\alpha</tex> of natural numbers by <tex>| \alpha | =  \sum _{j  \in   \mathbf {m}}  \alpha _j</tex>. For any function <tex>f  \in   \operatorname {Hom}_{ \mathsf { Fin } }( \mathbf {n} ,  \mathbf {m} )</tex> define an <tex>m</tex>-tuple <tex>\alpha ^f :  \mathbf {m}  \to   \mathbb {N}</tex> by <tex>\alpha ^f_j = |f^{-1}(j)|</tex>. Since the fibers of <tex>f</tex> are disjoint we have <tex display="block">| \alpha ^f| =  \sum _{j  \in   \mathbf {m}} |f^{-1}(j)| =  \left | \bigcup _{j  \in   \mathbf {m}} f^{-1}(j)  \right | =  \left |f^{-1} \left ( \bigcup _{j  \in   \mathbf {m}}  \{ j \} \right )  \right | = |f^{-1}( \mathbf {m})| = | \mathbf {n}| = n.</tex></p>

<p>We argue that <tex>f, g</tex> lie in the same orbit if and only if <tex>\alpha ^f =  \alpha ^g</tex>. For &quot;only if&quot; direction we just observe that <tex>f =  g   \mathbin { \circ }  \sigma</tex> implies <tex>\sigma (f^{-1}(j)) = g^{-1}(j)</tex> for any <tex>j  \in   \mathbf {m}</tex>, hence <tex>\sigma</tex> restricts to a bijection between <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> and so <tex>\alpha ^f_j = |f^{-1}(j)| = |g^{-1}(j)| =  \alpha ^g_j</tex>, as desired. Suppose <tex>\alpha ^f =  \alpha ^g</tex>, so that we may prove the other implication. Then for any <tex>j \in   \mathbf {m}</tex> we have <tex>|f^{-1}(j)| = |g^{-1}(j)|</tex>, i.e. the sets <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> are in bijection. We may then fix arbitrary bijections <tex>\sigma _j : f^{-1}(j)  \to  g^{-1}(j)</tex>. By construction we have <tex>g( \sigma _{f(i)}(i)) = f(i)</tex>. Define a function <tex>\sigma  :  \mathbf {n}  \to   \mathbf {n}</tex> by <tex>\sigma (i) =  \sigma _{f(i)}(i)</tex>; this is well defined because (trivially) <tex>i  \in  f^{-1}(f(i))</tex>. For any <tex>j  \in   \mathbf {m}</tex> and <tex>i'  \in  g^{-1}(j)</tex> the element <tex>i =  \sigma _j^{-1}(j)</tex> satisfies <tex>i  \in  f^{-1}(j)</tex> and thus <tex display="block">\sigma (i) =  \sigma _{j}(i) =  \sigma _{j}( \sigma _j^{-1}(j)) = i.</tex>
This proves that <tex>\operatorname {im}( \sigma )   \supseteq  g^{-1}(j)</tex> for any <tex>j  \in   \mathbf {m}</tex>. And it's immediate from this that <tex>\sigma</tex> is surjective, since the union of the fibers <tex>g^{-1}(j)</tex> over all <tex>j  \in   \mathbf {m}</tex> is <tex>\mathbf {n}</tex>. Since <tex>\sigma</tex> has domain and codomain finite sets of the same cardinality, surjectivity in fact implies <tex>\sigma   \in  S_n</tex>. Finally observe that <tex>f = g  \circ   \sigma</tex>, as we have defined <tex>\sigma</tex> such that this equation holds on each fiber <tex>f^{-1}(j)</tex>.</p>
 
<p>To complete our proof we need to show that the association <tex>f  \mapsto   \alpha ^f</tex> defines a bijection between <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> and the set <tex>X</tex> of <tex>m</tex>-tuples with weight <tex>n</tex>. Let <tex>\Phi  :  \operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )   \to  X</tex> be this function. Awkwardly we need to treat the case <tex>m = 0</tex> separately. Here we further case split on whether <tex>n = 0</tex>, in which case <tex>\operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> and <tex>X</tex> both have a unique element, or <tex>n  \neq  0</tex>, in which case both sets are empty. Either way, <tex>\Phi</tex> is automatically a bijection. So now assume <tex>m &gt; 0</tex>. We define an inverse <tex>\Psi  : X  \to   \operatorname {Hom}_{ \Delta }( \mathbf {n} ,  \mathbf {m} )</tex> by <tex display="block">\Psi ( \alpha )(i) =  \max   \left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \right \} .</tex> Before we can check that <tex>\Psi</tex> is an inverse to <tex>\Phi</tex> we must show that <tex>\Psi ( \alpha )</tex> is a well-defined function <tex>\mathbf {n}  \to   \mathbf {m}</tex> for any <tex>\alpha   \in  X</tex>, and that this function is monotone. The function is well-defined because any nonempty totally ordered set has a maximum and the set in the definition of <tex>\Psi ( \alpha )</tex> always contains <tex>0</tex>. And <tex>\Psi ( \alpha )</tex> is monotone because if <tex>i_1  \leq  i_2</tex> then <tex>i_0  \leq  i_1</tex> only if <tex>i_0  \leq  i_2</tex> and thus <tex display="block">\left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_1  \right \}   \subseteq   \left \{  k  \in   \mathbf {m}  \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_2  \right \} .</tex> Clearly taking the maximum of a larger sets gives a larger result, so this inclusion proves <tex>\Psi ( \alpha )(i_1)  \leq   \Psi ( \alpha )(i_2)</tex>. We may now check that <tex>\Phi</tex> and <tex>\Psi</tex> are inverses. Given <tex>\alpha   \in  X</tex> we have <tex display="block">\Phi ( \Psi ( \alpha ))_k = | \Psi ( \alpha )^{-1}(k)| =  \left | \left \{  i  \in   \mathbf {n}  \; \middle | \;     \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \text { and } i &lt;  \sum _{0  \leq  j  \leq  k}  \alpha _j  \right \} \right | =  \alpha _k</tex> for any <tex>k  \in   \mathbf {m}</tex>. We establish the identity <tex>\Psi ( \Phi (f)) = f</tex> by showing that <tex>\sum _{0  \leq  j &lt; k} |f^{-1}(j)|  \leq  i</tex> if and only if <tex>k  \leq  f(i)</tex>, for any monotone function <tex>f :  \mathbf {n}  \to   \mathbf {m}</tex>, <tex>i  \in   \mathbf {n}</tex>, and <tex>k  \in   \mathbf {m}</tex> (from which it is obvious that <tex>\Psi ( \Phi (f))(i) = f(i)</tex>). Let <tex>\ell  =  \sum _{0  \leq  j &lt; k} |f^{-1}(j)|</tex>; we show <tex>\ell  &gt; i</tex> iff <tex>k &gt; f(i)</tex>. By monotonicity of <tex>f</tex> the set <tex>f^{-1}( \mathbf {k})  \subseteq   \mathbf {n}</tex> is downwards-closed, hence it is itself an ordinal and more specifically <tex>f^{-1}( \mathbf {k}) =  \mathbf { \ell }</tex>. Thus <tex>\ell  &gt; i</tex> iff <tex>i  \in  f^{-1}( \mathbf {k})</tex> iff <tex>f(i)  \in   \mathbf {k}</tex> iff <tex>f(i) &lt; k</tex>.
</p></block>
</mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>256</anchor>  <taxon>Definition</taxon> <addr>bnc-0003</addr>  <route>bnc-0003.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { C }</tex> and <tex>\mathsf { D }</tex> be <link href="bnc-0002.xml" type="local" title="Category">categories</link>. A functor <tex>F :  \mathsf { C }   \to   \mathsf { D }</tex> consists of class functions <tex>F_0 :  \operatorname {Obj}( \mathsf { C } )   \to   \operatorname {Obj}( \mathsf { D } )</tex> and <tex>F_1 :  \operatorname {Mor}( \mathsf { C } )   \to   \operatorname {Mor}( \mathsf { D } )</tex>. The axioms of a functor are:</p><ol><li><tex>F_1( \operatorname {id} _{ x } ) =  \operatorname {id} _{ F_0(x) }</tex> for any <tex>x  \in   \operatorname {Obj}( \mathsf { C } )</tex>,</li>
  <li><tex>s(F_1(f)) = F_0(s(f))</tex> and <tex>t(F_1(f)) = F_0(t(f))</tex> for any <tex>f  \in   \operatorname {Mor}( \mathsf { C } )</tex>,</li>
  <li>for any <tex>f, g  \in   \operatorname {Mor}( \mathsf { C } )</tex> if <tex>s(f) = t(g)</tex> then <tex>F_1( f   \mathbin { \circ }  g ) =  F_1(f)   \mathbin { \circ }  F_1(g)</tex>.</li></ol><p>If <tex>\mathsf { C }</tex> is small then the functions <tex>F_0 :  \operatorname {Obj}( \mathsf { C } )   \to   \operatorname {Obj}( \mathsf { D } )</tex>, <tex>F_1 :  \operatorname {Mor}( \mathsf { C } )   \to   \operatorname {Mor}( \mathsf { D } )</tex> are actually sets (not proper classes), as their domains are sets. There is then a class of all functors <tex>\mathsf { C }   \to   \mathsf { D }</tex> (even if <tex>\mathsf { D }</tex> is large). For <tex>x  \in   \operatorname {Obj}( \mathsf { C } )</tex> and <tex>f  \in   \operatorname {Mor}( \mathsf { C } )</tex> we'll generally write <tex>F(x)</tex> to mean <tex>F_0(x)</tex> and <tex>F(f)</tex> to mean <tex>F_1(f)</tex>; this is undoubtedly ambiguous, but it's usually clear which is meant from context.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>257</anchor>  <taxon>Definition</taxon> <addr>bnc-0004</addr>  <route>bnc-0004.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Natural Transformation</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf { C }</tex>, <tex>\mathsf { D }</tex> be <link href="bnc-0002.xml" type="local" title="Category">categories</link> and <tex>F, G :  \mathsf { C }   \to   \mathsf { D }</tex> <link href="bnc-0003.xml" type="local" title="Functor">functors</link> between them. The data of a natural transformation <tex>\alpha  : F  \to  G</tex> is a class function <tex>\operatorname {Obj}( \mathsf { C } )   \to   \operatorname {Mor}( \mathsf { D } )</tex> (also denoted <tex>\alpha</tex>). The axioms of a natural transformation are:</p><ol><li><tex>\alpha _x  \in   \operatorname {Hom}_{ \mathsf { D } }( F(x) ,  G(x) )</tex> for any <tex>x  \in   \operatorname {Obj}( \mathsf { C } )</tex>,</li>
  <li>For any <tex>f  \in   \operatorname {Mor}( \mathsf { C } )</tex>, if <tex>x = s(f)</tex> and <tex>y = t(f)</tex> then <tex>\alpha _y   \mathbin { \circ }  F(f)  =  G(f)   \mathbin { \circ }  \alpha _x</tex>.</li></ol><p>As above, we usually write application of natural transformations with a subscript. Also, if a natural transformation has an inverse natural transformation we refer to it as a natural isomorphism.</p><p>In analogy with representation theory we could think of <tex>\alpha</tex> as an &quot;intertwiner&quot; betwen <tex>F</tex> and <tex>G</tex>. As functors are morphisms between categories, natural transformations are morphisms between functors. Also, if <tex>\mathsf { C }</tex> is a small category and <tex>F, G</tex> are functors out of <tex>\mathsf { C }   \to   \mathsf { D }</tex> then individual natural transformations <tex>F  \to  G</tex> are sets, hence they can be collected into a class of all natural transformations <tex>F  \to  G</tex>.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="true"><frontmatter> <anchor>258</anchor>   <addr>BSM-0001</addr>  <route>index.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>The root of my forest</title> </frontmatter> <mainmatter><p>I'm writing some ongoing <link href="bnc-0001.xml" type="local" title="Foundations of category theory">notes</link> on category theory right now.</p></mainmatter> </tree></contributions> <context/> <related/> <backlinks/> <references/></backmatter></tree>