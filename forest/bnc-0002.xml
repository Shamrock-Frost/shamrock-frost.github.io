<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>139</anchor>  <taxon>Definition</taxon> <addr>bnc-0002</addr>  <route>bnc-0002.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Category</title> </frontmatter> <mainmatter><p>A category <tex>\mathsf{C}</tex> consists of classes <tex>C_0</tex>, <tex>C_1</tex>, class functions <tex>s,t : C_1  \to  C_0</tex>, a common section <tex>\operatorname{id}  : C_0  \to  C_1</tex> of <tex>s, t</tex>, and a partial operator <tex>\circ  : C_1  \times  C_1  \rightharpoonup  C_1</tex> where <tex>f   \mathbin{\circ}   g</tex> is defined iff <tex>s(f) = t(g)</tex>. The axioms of a category are:</p><ol>  <li><tex>s( f   \mathbin{\circ}   g ) = s(g)</tex> and <tex>t( f   \mathbin{\circ}   g ) = t(f)</tex> for any <tex>f, g \in  C_1</tex> such that <tex>s(f) = t(g)</tex>,</li>  <li><tex>\operatorname{id} _{ t(f) }   \mathbin{\circ}   f  = f =  f   \mathbin{\circ}   \operatorname{id} _{ s(f) }</tex> for any <tex>f \in  C_1</tex>,</li>  <li>for any <tex>f, g, h  \in  C_1</tex> such that <tex>s(f) = t(g)</tex> and <tex>s(g) = t(h)</tex>, <tex display="block">f   \mathbin{\circ}   ( g   \mathbin{\circ}   h )  =  ( f   \mathbin{\circ}   g )   \mathbin{\circ}   h .</tex></li></ol><p>As above, we usually write <tex>\circ</tex> as an infix operator and write application of <tex>\operatorname{id}</tex> with a subscript.</p><p>If <tex>x,y  \in  C_0</tex> we define <tex>\operatorname{Hom} _{ \mathsf{C} }( x ,  y )  = s ^{ -1 } (x)  \cap  t ^{ -1 } (y)</tex>, so <tex>\operatorname{id} _{ x }   \in   \operatorname{Hom} _{ \mathsf{C} }( x ,  x )</tex>. For <tex>f  \in  C_1</tex> we refer to <tex>s(f)</tex> as the &quot;source&quot; of <tex>f</tex> and <tex>t(f)</tex> as the &quot;target&quot; of <tex>f</tex>. A category <tex>\mathsf{C}</tex> is said to be small if <tex>C_1</tex> is a set (which implies <tex>C_0</tex> is a set) and to be locally small if <tex>\operatorname{Hom} _{ \mathsf{C} }( x ,  y )</tex> is a set for all <tex>x, y  \in  C_0</tex>. For a general category <tex>\mathsf{C}</tex> we refer to <tex>\operatorname{Hom} _{ \mathsf{C} }( x ,  y )</tex> as a <tex>\operatorname{Hom}</tex>-class of <tex>\mathsf{C}</tex>, and if <tex>\mathsf{C}</tex> is locally small we call it a <tex>\operatorname{Hom}</tex>-<em>set</em>. We write <tex>\operatorname{Obj} ( \mathsf{C} )</tex> for the class <tex>C_0</tex> and <tex>\operatorname{Mor} ( \mathsf{C} )</tex> for <tex>C_1</tex>.</p></mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>140</anchor>   <addr>bnc-0001</addr>  <route>bnc-0001.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Foundations of category theory</title> </frontmatter> <mainmatter><p>In the following we work in NBG set theory with the axiom of choice but not of global choice. I will probably crack at some point and bring in universes. I intend for these notes to be as self contained as possible, but that goal may change.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>141</anchor>  <taxon>Definition</taxon> <addr>bnc-0002</addr>  <route>bnc-0002.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Category</title> </frontmatter> <mainmatter><p>A category <tex>\mathsf{C}</tex> consists of classes <tex>C_0</tex>, <tex>C_1</tex>, class functions <tex>s,t : C_1  \to  C_0</tex>, a common section <tex>\operatorname{id}  : C_0  \to  C_1</tex> of <tex>s, t</tex>, and a partial operator <tex>\circ  : C_1  \times  C_1  \rightharpoonup  C_1</tex> where <tex>f   \mathbin{\circ}   g</tex> is defined iff <tex>s(f) = t(g)</tex>. The axioms of a category are:</p><ol>  <li><tex>s( f   \mathbin{\circ}   g ) = s(g)</tex> and <tex>t( f   \mathbin{\circ}   g ) = t(f)</tex> for any <tex>f, g \in  C_1</tex> such that <tex>s(f) = t(g)</tex>,</li>  <li><tex>\operatorname{id} _{ t(f) }   \mathbin{\circ}   f  = f =  f   \mathbin{\circ}   \operatorname{id} _{ s(f) }</tex> for any <tex>f \in  C_1</tex>,</li>  <li>for any <tex>f, g, h  \in  C_1</tex> such that <tex>s(f) = t(g)</tex> and <tex>s(g) = t(h)</tex>, <tex display="block">f   \mathbin{\circ}   ( g   \mathbin{\circ}   h )  =  ( f   \mathbin{\circ}   g )   \mathbin{\circ}   h .</tex></li></ol><p>As above, we usually write <tex>\circ</tex> as an infix operator and write application of <tex>\operatorname{id}</tex> with a subscript.</p><p>If <tex>x,y  \in  C_0</tex> we define <tex>\operatorname{Hom} _{ \mathsf{C} }( x ,  y )  = s ^{ -1 } (x)  \cap  t ^{ -1 } (y)</tex>, so <tex>\operatorname{id} _{ x }   \in   \operatorname{Hom} _{ \mathsf{C} }( x ,  x )</tex>. For <tex>f  \in  C_1</tex> we refer to <tex>s(f)</tex> as the &quot;source&quot; of <tex>f</tex> and <tex>t(f)</tex> as the &quot;target&quot; of <tex>f</tex>. A category <tex>\mathsf{C}</tex> is said to be small if <tex>C_1</tex> is a set (which implies <tex>C_0</tex> is a set) and to be locally small if <tex>\operatorname{Hom} _{ \mathsf{C} }( x ,  y )</tex> is a set for all <tex>x, y  \in  C_0</tex>. For a general category <tex>\mathsf{C}</tex> we refer to <tex>\operatorname{Hom} _{ \mathsf{C} }( x ,  y )</tex> as a <tex>\operatorname{Hom}</tex>-class of <tex>\mathsf{C}</tex>, and if <tex>\mathsf{C}</tex> is locally small we call it a <tex>\operatorname{Hom}</tex>-<em>set</em>. We write <tex>\operatorname{Obj} ( \mathsf{C} )</tex> for the class <tex>C_0</tex> and <tex>\operatorname{Mor} ( \mathsf{C} )</tex> for <tex>C_1</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>142</anchor>  <taxon>Definition</taxon> <addr>bnc-0003</addr>  <route>bnc-0003.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf{C}</tex> and <tex>\mathsf{D}</tex> be <link href="bnc-0002.xml" type="local" title="Categories">categories</link>. A functor <tex>F :  \mathsf{C}   \to   \mathsf{D}</tex> consists of class functions <tex>F_0 :  \operatorname{Obj} ( \mathsf{C} )   \to   \operatorname{Obj} ( \mathsf{D} )</tex> and <tex>F_1 :  \operatorname{Mor} ( \mathsf{C} )   \to   \operatorname{Mor} ( \mathsf{D} )</tex>. The axioms of a functor are:</p><ol>  <li><tex>F_1( \operatorname{id} _{ x } ) =  \operatorname{id} _{ F_0(x) }</tex> for any <tex>x  \in   \operatorname{Obj} ( \mathsf{C} )</tex>,</li>  <li><tex>s(F_1(f)) = F_0(s(f))</tex> and <tex>t(F_1(f)) = F_0(t(f))</tex> for any <tex>f  \in   \operatorname{Mor} ( \mathsf{C} )</tex>,</li>  <li>for any <tex>f, g  \in   \operatorname{Mor} ( \mathsf{C} )</tex> if <tex>s(f) = t(g)</tex> then <tex>F_1( f   \mathbin{\circ}   g ) =  F_1(f)   \mathbin{\circ}   F_1(g)</tex>.</li></ol><p>If <tex>\mathsf{C}</tex> is small then the functions <tex>F_0 :  \operatorname{Obj} ( \mathsf{C} )   \to   \operatorname{Obj} ( \mathsf{D} )</tex>, <tex>F_1 :  \operatorname{Mor} ( \mathsf{C} )   \to   \operatorname{Mor} ( \mathsf{D} )</tex> are actually sets (not proper classes), as their domains are sets. There is then a class of all functors <tex>\mathsf{C}   \to   \mathsf{D}</tex> (even if <tex>\mathsf{D}</tex> is large). For <tex>x  \in   \operatorname{Obj} ( \mathsf{C} )</tex> and <tex>f  \in   \operatorname{Mor} ( \mathsf{C} )</tex> we'll generally write <tex>F(x)</tex> to mean <tex>F_0(x)</tex> and <tex>F(f)</tex> to mean <tex>F_1(f)</tex>; this is undoubtedly ambiguous, but it's usually clear which is meant from context.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>143</anchor>  <taxon>Definition</taxon> <addr>bnc-0004</addr>  <route>bnc-0004.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Natural Transformation</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf{C}</tex>, <tex>\mathsf{D}</tex> be <link href="bnc-0002.xml" type="local" title="Categories">categories</link> and <tex>F, G :  \mathsf{C}   \to   \mathsf{D}</tex> <link href="bnc-0003.xml" type="local" title="Functors">functors</link> between them. The data of a natural transformation <tex>\alpha  : F  \to  G</tex> is a class function <tex>\operatorname{Obj} ( \mathsf{C} )   \to   \operatorname{Mor} ( \mathsf{D} )</tex> (also denoted <tex>\alpha</tex>). The axioms of a natural transformation are:</p><ol>  <li><tex>\alpha _x  \in   \operatorname{Hom} _{ \mathsf{D} }( F(x) ,  G(x) )</tex> for any <tex>x  \in   \operatorname{Obj} ( \mathsf{C} )</tex>,</li>  <li>For any <tex>f  \in   \operatorname{Mor} ( \mathsf{C} )</tex>, if <tex>x = s(f)</tex> and <tex>y = t(f)</tex> then <tex>\alpha _y   \mathbin{\circ}   F(f)  =  G(f)   \mathbin{\circ}   \alpha _x</tex>.</li></ol><p>As above, we usually write application of natural transformations with a subscript. Also, if a natural transformation has an inverse natural transformation we refer to it as a natural isomorphism.</p><p>In analogy with representation theory we could think of <tex>\alpha</tex> as an &quot;intertwiner&quot; betwen <tex>F</tex> and <tex>G</tex>. As functors are morphisms between categories, natural transformations are morphisms between functors. Also, if <tex>\mathsf{C}</tex> is a small category and <tex>F, G</tex> are functors out of <tex>\mathsf{C}   \to   \mathsf{D}</tex> then individual natural transformations <tex>F  \to  G</tex> are sets, hence they can be collected into a class of all natural transformations <tex>F  \to  G</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>144</anchor>   <addr>bnc-0006</addr>  <route>bnc-0006.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Combinatorics and categories</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>1</crumb></trail> <anchor>145</anchor>  <taxon>Definition</taxon> <addr>bnc-0007</addr>  <route>bnc-0007.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Simplex Category</title> </frontmatter> <mainmatter><p>The simplex category is the category <tex>\Delta</tex> whose objects are the finite ordinals <tex>\mathbf{n}  =  \{  i  \in   \mathbb{N}   \mid  i &lt; n  \}  =  \{ 0, \ldots ,n-1 \}</tex> and whose morphisms are the order preserving maps; note <tex>\Delta</tex> is a full subcategory of the category <tex>\mathsf{Pos}</tex> of posets. We include the empty set <tex>\mathbf{0}</tex>, so in other conventions this would be called the &quot;augmented simplex category&quot; or the &quot;algebraists' simplex category&quot;.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb></trail> <anchor>146</anchor>  <taxon>Definition</taxon> <addr>bnc-0008</addr>  <route>bnc-0008.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Variants of the category of finite sets</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf{FinSet}</tex> be the category of finite sets. This is a large, locally small category but it has only countably many isomorphism classes. The set <tex>\omega</tex> of finite ordinals (equivalently finite cardinals) contains exactly one object in each isomorphism class of <tex>\mathsf{FinSet}</tex>, hence if <tex>\mathsf{Fin}</tex> is the full subcategory of <tex>\mathsf{FinSet}</tex> on objects <tex>\omega</tex> then the inclusion <tex>\mathsf{Fin}   \hookrightarrow   \mathsf{FinSet}</tex> is essentially surjective. It is also manifestly fully faithful, i.e. is an equivalence of categories (although it's consistent that there is no quasi-inverse, in the absence of global choice!). Another small model for <tex>\mathsf{FinSet}</tex> is the full subcategory <tex>\mathsf{HFinSet}</tex> on <tex>V_{ \omega }</tex>, the hereditarily finite sets. This latter model is nice in that it is closed under finite limits and colimits in a very strong sense: the <em>standard constructions</em> of (co)limits in <tex>\mathsf{Set}</tex> will produce hereditarily finite sets when applied to hereditarily finite diagrams of hereditarily finite sets. In summary we have full subcategory inclusions <tex>\mathsf{Fin}   \subseteq   \mathsf{HFinSet}   \subseteq   \mathsf{FinSet}</tex>, each being an equivalence, each of these categories is an elementary topos, and the inclusion <tex>\mathsf{HFinSet}   \subseteq   \mathsf{Set}</tex> preserves &quot;explicit choices of (co)limits&quot; when that makes sense.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>3</crumb></trail> <anchor>147</anchor>  <taxon>Definition</taxon> <addr>bnc-000B</addr>  <route>bnc-000B.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>The symmetric groups</title> </frontmatter> <mainmatter>






<p>The symmetric group <tex>S_n</tex>, defined with respect to a parameter <tex>n  \in   \mathbb{N}</tex>, is the set of permutations of the <tex>n</tex>-element set. Of course there is a proper class of <tex>n</tex>-element sets and so for concreteness we define <tex>S_n</tex> to be the group of self-bijections of the <tex>n</tex>th ordinal <tex>\mathbf{n}  =  \{ i  \in   \mathbb{N}   \mid  i &lt; n \}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>4</crumb></trail> <anchor>148</anchor>  <taxon>Proposition</taxon> <addr>bnc-000C</addr>  <route>bnc-000C.xml</route> <date><year>2023</year> <month>10</month> <day>1</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Orbits of the symmetric group action on functions</title> </frontmatter> <mainmatter>







<p>Let <tex>n, m  \in   \mathbb{N}</tex>. Since <tex>S_n =  \operatorname{Aut} _{ \mathsf{Fin} }( \mathbf{n} )</tex> there is a canonical right action of <tex>S_n</tex> on <tex>\operatorname{Hom} _{ \mathsf{Fin} }( \mathbf{n} ,  \mathbf{m} )</tex>, via precomposition. Each orbit of this action contains exactly one element of <tex>\operatorname{Hom} _{ \Delta }( \mathbf{n} ,  \mathbf{m} )</tex>.</p>

  <block open="open"><headline><b>Proof</b>.</headline> <p>Define the weight of an <tex>m</tex>-tuple <tex>\alpha</tex> of natural numbers by <tex>| \alpha | =  \sum _{j  \in   \mathbf{m} }  \alpha _j</tex>. For any function <tex>f  \in   \operatorname{Hom} _{ \mathsf{Fin} }( \mathbf{n} ,  \mathbf{m} )</tex> define an <tex>m</tex>-tuple <tex>\alpha ^f :  \mathbf{m}   \to   \mathbb{N}</tex> by <tex>\alpha ^f_j = |f^{-1}(j)|</tex>. Since the fibers of <tex>f</tex> are disjoint we have <tex display="block">| \alpha ^f| =  \sum _{j  \in   \mathbf{m} } |f^{-1}(j)| =  \left | \bigcup _{j  \in   \mathbf{m} } f^{-1}(j)  \right | =  \left |f^{-1} \left ( \bigcup _{j  \in   \mathbf{m} }  \{ j \} \right )  \right | = |f^{-1}( \mathbf{m} )| = | \mathbf{n} | = n.</tex></p>

<p>We argue that <tex>f, g</tex> lie in the same orbit if and only if <tex>\alpha ^f =  \alpha ^g</tex>. For &quot;only if&quot; direction we just observe that <tex>f =  g   \mathbin{\circ}   \sigma</tex> implies <tex>\sigma (f^{-1}(j)) = g^{-1}(j)</tex> for any <tex>j  \in   \mathbf{m}</tex>, hence <tex>\sigma</tex> restricts to a bijection between <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> and so <tex>\alpha ^f_j = |f^{-1}(j)| = |g^{-1}(j)| =  \alpha ^g_j</tex>, as desired. Suppose <tex>\alpha ^f =  \alpha ^g</tex>, so that we may prove the other implication. Then for any <tex>j \in   \mathbf{m}</tex> we have <tex>|f^{-1}(j)| = |g^{-1}(j)|</tex>, i.e. the sets <tex>f^{-1}(j)</tex> and <tex>g^{-1}(j)</tex> are in bijection. We may then fix arbitrary bijections <tex>\sigma _j : f^{-1}(j)  \to  g^{-1}(j)</tex>. By construction <tex>g( \sigma _{j}(i)) = f(i)</tex> for any <tex>i  \in  f^{-1}(j)</tex>. Define <tex>\sigma  :  \mathbf{n}   \to   \mathbf{n}</tex> by <tex>\sigma (i) =  \sigma _{f(i)}(i)</tex>; this is well defined because (trivially) <tex>i  \in  f^{-1}(f(i))</tex>. For any <tex>j  \in   \mathbf{m}</tex> and <tex>i'  \in  g^{-1}(j)</tex> the element <tex>i =  \sigma _j^{-1}(i')</tex> satisfies <tex>i  \in  f^{-1}(j)</tex> and thus <tex display="block">\sigma (i) =  \sigma _{j}(i) =  \sigma _{j}( \sigma _j^{-1}(i')) = i'.</tex> This proves that <tex>\operatorname{im} ( \sigma )   \supseteq  g^{-1}(j)</tex> for any <tex>j  \in   \mathbf{m}</tex>. And it's immediate from this that <tex>\sigma</tex> is surjective, since the union of the fibers <tex>g^{-1}(j)</tex> over all <tex>j  \in   \mathbf{m}</tex> is <tex>\mathbf{n}</tex>. Since the domain and codomain of <tex>\sigma</tex> are finite sets, of the same cardinality, surjectivity implies <tex>\sigma   \in  S_n</tex>. Finally observe <tex>f = g  \circ   \sigma</tex>, as we have defined <tex>\sigma</tex> such that this equation holds on each fiber <tex>f^{-1}(j)</tex>.</p>
 
<p>To complete our proof we need to show that the association <tex>f  \mapsto   \alpha ^f</tex> defines a bijection between <tex>\operatorname{Hom} _{ \Delta }( \mathbf{n} ,  \mathbf{m} )</tex> and the set <tex>X</tex> of <tex>m</tex>-tuples with weight <tex>n</tex>. Let <tex>\Phi  :  \operatorname{Hom} _{ \Delta }( \mathbf{n} ,  \mathbf{m} )   \to  X</tex> be this function. Awkwardly we need to treat the case <tex>m = 0</tex> separately. In this case we further case split on whether <tex>n = 0</tex>, in which case <tex>\operatorname{Hom} _{ \Delta }( \mathbf{n} ,  \mathbf{m} )</tex> and <tex>X</tex> both have a unique element, or <tex>n  \neq  0</tex>, in which case both sets are empty. Either way, <tex>\Phi</tex> is automatically a bijection. So now assume <tex>m &gt; 0</tex>. We define an inverse <tex>\Psi  : X  \to   \operatorname{Hom} _{ \Delta }( \mathbf{n} ,  \mathbf{m} )</tex> by <tex display="block">\Psi ( \alpha )(i) =  \max   \left \{  k  \in   \mathbf{m}   \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \right \} .</tex> Before we can check that <tex>\Psi</tex> is an inverse to <tex>\Phi</tex> we must show that <tex>\Psi ( \alpha )</tex> is a well-defined function <tex>\mathbf{n}   \to   \mathbf{m}</tex> for any <tex>\alpha   \in  X</tex>, and that this function is monotone. The function is well-defined because any nonempty totally ordered set has a maximum and the set in the definition of <tex>\Psi ( \alpha )</tex> always contains <tex>0</tex>. And <tex>\Psi ( \alpha )</tex> is monotone because if <tex>i_1  \leq  i_2</tex> then <tex display="block">\left \{  k  \in   \mathbf{m}   \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_1  \right \}   \subseteq   \left \{  k  \in   \mathbf{m}   \; \middle | \;   \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i_2  \right \}</tex> and taking the maximum of a larger set clearly gives a larger result, so <tex>\Psi ( \alpha )(i_1)  \leq   \Psi ( \alpha )(i_2)</tex>. We may now check that <tex>\Phi</tex> and <tex>\Psi</tex> are inverses. Given <tex>\alpha   \in  X</tex> we have <tex display="block">\Phi ( \Psi ( \alpha ))_k = | \Psi ( \alpha )^{-1}(k)| =  \left | \left \{  i  \in   \mathbf{n}   \; \middle | \;     \sum _{0  \leq  j &lt; k}  \alpha _j  \leq  i  \text{ and }  i &lt;  \sum _{0  \leq  j  \leq  k}  \alpha _j  \right \} \right | =  \alpha _k</tex> for any <tex>k  \in   \mathbf{m}</tex>. We establish the identity <tex>\Psi ( \Phi (f)) = f</tex> by showing <tex>\sum _{0  \leq  j &lt; k} |f^{-1}(j)|  \leq  i</tex> if and only if <tex>k  \leq  f(i)</tex> for any monotone function <tex>f :  \mathbf{n}   \to   \mathbf{m}</tex>, <tex>i  \in   \mathbf{n}</tex>, and <tex>k  \in   \mathbf{m}</tex>. Let <tex>\ell  =  \sum _{0  \leq  j &lt; k} |f^{-1}(j)|</tex>; we show <tex>\ell  &gt; i</tex> iff <tex>k &gt; f(i)</tex>. By monotonicity of <tex>f</tex> the set <tex>f^{-1}( \mathbf{k} )  \subseteq   \mathbf{n}</tex> is downwards-closed, hence it is itself an ordinal and more specifically we have <tex>f^{-1}( \mathbf{k} ) =  \mathbf{\ell}</tex>. Thus <tex>\ell  &gt; i</tex> iff <tex>i  \in  f^{-1}( \mathbf{k} )</tex> iff <tex>f(i)  \in   \mathbf{k}</tex> iff <tex>f(i) &lt; k</tex>.</p></block>
</mainmatter> </tree></mainmatter> </tree></mainmatter> </tree></context> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>149</anchor>  <taxon>Definition</taxon> <addr>bnc-0005</addr>  <route>bnc-0005.xml</route> <date><year>2023</year> <month>9</month> <day>28</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Monoidal Category</title> </frontmatter> <mainmatter><p>A monoidal category consists of a <link href="bnc-0002.xml" type="local" title="Category">category</link> <tex>\mathsf{M}</tex>, a <link href="bnc-0003.xml" type="local" title="Functor">functor</link> <tex>\otimes  :  \mathsf{C}   \times   \mathsf{C}   \to   \mathsf{C}</tex>, an object <tex>\mathbb{k}</tex> of <tex>\mathsf{M}</tex>, and <link href="bnc-0004.xml" type="local" title="Natural isomorphisms">natural isomorphisms</link> <tex>\alpha _{x,y,z} : (x  \otimes  y)  \otimes  z  \to   x  \otimes  (y  \otimes  z)</tex>, <tex>\lambda _x :  \mathbb{k}   \otimes  x  \to  x</tex>, and <tex>\rho _x : x  \otimes   \mathbb{k}   \to  x</tex>.</p><center><img src="resources/eb9447da96b30603fc2b6a97e45ce903-web.svg"/></center></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>150</anchor>  <taxon>Definition</taxon> <addr>bnc-0003</addr>  <route>bnc-0003.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Functor</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf{C}</tex> and <tex>\mathsf{D}</tex> be <link href="bnc-0002.xml" type="local" title="Categories">categories</link>. A functor <tex>F :  \mathsf{C}   \to   \mathsf{D}</tex> consists of class functions <tex>F_0 :  \operatorname{Obj} ( \mathsf{C} )   \to   \operatorname{Obj} ( \mathsf{D} )</tex> and <tex>F_1 :  \operatorname{Mor} ( \mathsf{C} )   \to   \operatorname{Mor} ( \mathsf{D} )</tex>. The axioms of a functor are:</p><ol>  <li><tex>F_1( \operatorname{id} _{ x } ) =  \operatorname{id} _{ F_0(x) }</tex> for any <tex>x  \in   \operatorname{Obj} ( \mathsf{C} )</tex>,</li>  <li><tex>s(F_1(f)) = F_0(s(f))</tex> and <tex>t(F_1(f)) = F_0(t(f))</tex> for any <tex>f  \in   \operatorname{Mor} ( \mathsf{C} )</tex>,</li>  <li>for any <tex>f, g  \in   \operatorname{Mor} ( \mathsf{C} )</tex> if <tex>s(f) = t(g)</tex> then <tex>F_1( f   \mathbin{\circ}   g ) =  F_1(f)   \mathbin{\circ}   F_1(g)</tex>.</li></ol><p>If <tex>\mathsf{C}</tex> is small then the functions <tex>F_0 :  \operatorname{Obj} ( \mathsf{C} )   \to   \operatorname{Obj} ( \mathsf{D} )</tex>, <tex>F_1 :  \operatorname{Mor} ( \mathsf{C} )   \to   \operatorname{Mor} ( \mathsf{D} )</tex> are actually sets (not proper classes), as their domains are sets. There is then a class of all functors <tex>\mathsf{C}   \to   \mathsf{D}</tex> (even if <tex>\mathsf{D}</tex> is large). For <tex>x  \in   \operatorname{Obj} ( \mathsf{C} )</tex> and <tex>f  \in   \operatorname{Mor} ( \mathsf{C} )</tex> we'll generally write <tex>F(x)</tex> to mean <tex>F_0(x)</tex> and <tex>F(f)</tex> to mean <tex>F_1(f)</tex>; this is undoubtedly ambiguous, but it's usually clear which is meant from context.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>151</anchor>  <taxon>Definition</taxon> <addr>bnc-0004</addr>  <route>bnc-0004.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="brendanseamasmurphy.xml" type="local">Brendan Seamas Murphy</link></author> </authors> <title>Natural Transformation</title> </frontmatter> <mainmatter><p>Let <tex>\mathsf{C}</tex>, <tex>\mathsf{D}</tex> be <link href="bnc-0002.xml" type="local" title="Categories">categories</link> and <tex>F, G :  \mathsf{C}   \to   \mathsf{D}</tex> <link href="bnc-0003.xml" type="local" title="Functors">functors</link> between them. The data of a natural transformation <tex>\alpha  : F  \to  G</tex> is a class function <tex>\operatorname{Obj} ( \mathsf{C} )   \to   \operatorname{Mor} ( \mathsf{D} )</tex> (also denoted <tex>\alpha</tex>). The axioms of a natural transformation are:</p><ol>  <li><tex>\alpha _x  \in   \operatorname{Hom} _{ \mathsf{D} }( F(x) ,  G(x) )</tex> for any <tex>x  \in   \operatorname{Obj} ( \mathsf{C} )</tex>,</li>  <li>For any <tex>f  \in   \operatorname{Mor} ( \mathsf{C} )</tex>, if <tex>x = s(f)</tex> and <tex>y = t(f)</tex> then <tex>\alpha _y   \mathbin{\circ}   F(f)  =  G(f)   \mathbin{\circ}   \alpha _x</tex>.</li></ol><p>As above, we usually write application of natural transformations with a subscript. Also, if a natural transformation has an inverse natural transformation we refer to it as a natural isomorphism.</p><p>In analogy with representation theory we could think of <tex>\alpha</tex> as an &quot;intertwiner&quot; betwen <tex>F</tex> and <tex>G</tex>. As functors are morphisms between categories, natural transformations are morphisms between functors. Also, if <tex>\mathsf{C}</tex> is a small category and <tex>F, G</tex> are functors out of <tex>\mathsf{C}   \to   \mathsf{D}</tex> then individual natural transformations <tex>F  \to  G</tex> are sets, hence they can be collected into a class of all natural transformations <tex>F  \to  G</tex>.</p></mainmatter> </tree></backlinks> <references/></backmatter></tree>